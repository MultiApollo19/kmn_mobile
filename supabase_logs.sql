-- User Logs table (for tracking logins)
create table if not exists public.user_logs (
  id bigint generated by default as identity primary key,
  user_name text not null,
  user_type text not null,
  login_time timestamp with time zone default timezone('utc'::text, now()) not null,
  department_name text
);

alter table public.user_logs enable row level security;
create policy "Allow public insert access" on public.user_logs for insert with check (true);
create policy "Allow public read access" on public.user_logs for select using (true);


-- Visits Log table (The complete history/archive)
create table if not exists public.visits_log (
  log_id bigint generated by default as identity primary key,
  visit_id bigint, 
  entry_time timestamp with time zone,
  exit_time timestamp with time zone,
  employee_id bigint,
  purpose_id bigint,
  badge_id bigint,
  visitor_name text,
  notes text,
  signature text,
  original_created_at timestamp with time zone,
  
  -- Log metadata
  log_action text, -- 'INSERT', 'UPDATE', 'COMPLETED'
  log_timestamp timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.visits_log enable row level security;
create policy "Allow public read access" on public.visits_log for select using (true);
create policy "Allow public insert access" on public.visits_log for insert with check (true);


-- Trigger Function to handle logging and auto-archiving
create or replace function public.handle_visits_log()
returns trigger as $$
begin
  if (TG_OP = 'INSERT') then
    insert into public.visits_log (
      visit_id, entry_time, exit_time, employee_id, purpose_id, badge_id, 
      visitor_name, notes, signature, original_created_at, log_action
    )
    values (
      NEW.id, NEW.entry_time, NEW.exit_time, NEW.employee_id, NEW.purpose_id, NEW.badge_id,
      NEW.visitor_name, NEW.notes, NEW.signature, NEW.created_at, 'INSERT'
    );
    return NEW;

  elsif (TG_OP = 'UPDATE') then
    -- Check if this is a checkout (exit_time changed from null to not null)
    if (OLD.exit_time is null and NEW.exit_time is not null) then
       -- Log as COMPLETED
       insert into public.visits_log (
        visit_id, entry_time, exit_time, employee_id, purpose_id, badge_id, 
        visitor_name, notes, signature, original_created_at, log_action
      )
      values (
        NEW.id, NEW.entry_time, NEW.exit_time, NEW.employee_id, NEW.purpose_id, NEW.badge_id,
        NEW.visitor_name, NEW.notes, NEW.signature, NEW.created_at, 'COMPLETED'
      );
      
      -- DELETE the visit from the main table (Auto-archive)
      delete from public.visits where id = NEW.id;
      
      return NEW;
    else
      -- Normal Update
       insert into public.visits_log (
        visit_id, entry_time, exit_time, employee_id, purpose_id, badge_id, 
        visitor_name, notes, signature, original_created_at, log_action
      )
      values (
        NEW.id, NEW.entry_time, NEW.exit_time, NEW.employee_id, NEW.purpose_id, NEW.badge_id,
        NEW.visitor_name, NEW.notes, NEW.signature, NEW.created_at, 'UPDATE'
      );
      return NEW;
    end if;
  end if;
  return null;
end;
$$ language plpgsql security definer;

-- Re-create Trigger on visits table
drop trigger if exists on_visit_change on public.visits;

-- Removed 'or delete' so it doesn't fire on the auto-deletion
create trigger on_visit_change
after insert or update on public.visits
for each row execute function public.handle_visits_log();