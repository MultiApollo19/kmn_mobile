-- Włączenie rozszerzenia pgcrypto
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Funkcja weryfikująca PIN pracownika (POPRAWIONA)
-- Dodano 'extensions' do search_path, aby funkcja widziała crypt() i gen_salt()
CREATE OR REPLACE FUNCTION verify_employee_pin(p_pin text)
RETURNS TABLE (
  id bigint,
  name text,
  role text,
  department_name text
)
SECURITY DEFINER
SET search_path = public, extensions
AS $$
DECLARE
  v_emp record;
BEGIN
  -- Iteracja po pracownikach
  FOR v_emp IN 
    SELECT e.id, e.name, e.role, e.pin_hash, d.name as department_name
    FROM employees e 
    LEFT JOIN departments d ON e.department_id = d.id 
  LOOP
    BEGIN
      -- Sprawdzenie hashu
      -- Używamy rzutowania na text dla pewności
      IF v_emp.pin_hash IS NOT NULL AND v_emp.pin_hash = crypt(p_pin, v_emp.pin_hash) THEN
        id := v_emp.id;
        name := v_emp.name;
        role := v_emp.role;
        department_name := v_emp.department_name;
        RETURN NEXT;
        RETURN; -- Znaleziono, koniec
      END IF;
    EXCEPTION WHEN OTHERS THEN
      -- Logowanie błędów może być trudne w funkcji zwracającej tabele, 
      -- ale w tym przypadku continue jest bezpieczne dla starych/złych hashy.
      CONTINUE;
    END;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Funkcja pomocnicza do aktualizacji PINu (POPRAWIONA)
CREATE OR REPLACE FUNCTION update_employee_pin_hash(p_employee_id bigint, p_pin text)
RETURNS void
SECURITY DEFINER
SET search_path = public, extensions
AS $$
BEGIN
  UPDATE employees
  SET pin_hash = crypt(p_pin, gen_salt('bf'))
  WHERE id = p_employee_id;
END;
$$ LANGUAGE plpgsql;

-- === INSTRUKCJE POMOCNICZE ===

-- Aby zresetować PIN dla WSZYSTKICH pracowników na '1234':
-- UPDATE employees SET pin_hash = crypt('1234', gen_salt('bf'));

-- Aby wygenerować hash dla pinu '1234' (do ręcznego wstawienia):
-- SELECT crypt('1234', gen_salt('bf'));
