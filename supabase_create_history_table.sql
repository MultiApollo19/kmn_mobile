-- Create Visit History table (Persistent Log)
drop table if exists public.visit_history cascade;

create table public.visit_history (
  history_id bigint generated by default as identity primary key,
  visit_id bigint not null,
  
  -- Timestamps
  entry_time timestamp with time zone not null,
  exit_time timestamp with time zone,
  
  -- Foreign Keys with EXPLICIT NAMES for PostgREST embedding
  employee_id bigint, 
  purpose_id bigint,
  badge_id bigint,
  exit_employee_id bigint,
  
  -- Snapshot Data
  visitor_name text,
  notes text,
  signature text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  is_system_exit boolean default false,
  
  -- Log Metadata
  recorded_at timestamp with time zone default timezone('utc'::text, now()) not null,
  operation_type text,

  -- Constraints
  constraint visit_history_employee_id_fkey foreign key (employee_id) references public.employees(id),
  constraint visit_history_purpose_id_fkey foreign key (purpose_id) references public.visit_purposes(id),
  constraint visit_history_badge_id_fkey foreign key (badge_id) references public.badges(id),
  constraint visit_history_exit_employee_id_fkey foreign key (exit_employee_id) references public.employees(id)
);

-- Indexes
create index idx_visit_history_visit_id on public.visit_history(visit_id);
create index idx_visit_history_entry_time on public.visit_history(entry_time);
create index idx_visit_history_is_system_exit on public.visit_history(is_system_exit);

-- Function to handle replication
create or replace function public.handle_visit_history()
returns trigger as $$
begin
  if (TG_OP = 'INSERT') then
    insert into public.visit_history (
      visit_id, entry_time, exit_time, employee_id, purpose_id, badge_id, 
      visitor_name, notes, signature, created_at, is_system_exit, exit_employee_id, 
      operation_type
    ) values (
      NEW.id, NEW.entry_time, NEW.exit_time, NEW.employee_id, NEW.purpose_id, NEW.badge_id,
      NEW.visitor_name, NEW.notes, NEW.signature, NEW.created_at, NEW.is_system_exit, NEW.exit_employee_id,
      'INSERT'
    );
    return NEW;
  elsif (TG_OP = 'UPDATE') then
    if exists (select 1 from public.visit_history where visit_id = NEW.id) then
        update public.visit_history set
            entry_time = NEW.entry_time,
            exit_time = NEW.exit_time,
            employee_id = NEW.employee_id,
            purpose_id = NEW.purpose_id,
            badge_id = NEW.badge_id,
            visitor_name = NEW.visitor_name,
            notes = NEW.notes,
            signature = NEW.signature,
            is_system_exit = NEW.is_system_exit,
            exit_employee_id = NEW.exit_employee_id,
            recorded_at = now(),
            operation_type = 'UPDATE'
        where visit_id = NEW.id;
    else
        insert into public.visit_history (
            visit_id, entry_time, exit_time, employee_id, purpose_id, badge_id, 
            visitor_name, notes, signature, created_at, is_system_exit, exit_employee_id, 
            operation_type
        ) values (
            NEW.id, NEW.entry_time, NEW.exit_time, NEW.employee_id, NEW.purpose_id, NEW.badge_id,
            NEW.visitor_name, NEW.notes, NEW.signature, NEW.created_at, NEW.is_system_exit, NEW.exit_employee_id,
            'UPDATE_FALLBACK'
        );
    end if;
    return NEW;
  end if;
  return null;
end;
$$ language plpgsql security definer;

-- Trigger
drop trigger if exists on_visit_change_history on public.visits;
create trigger on_visit_change_history
  after insert or update on public.visits
  for each row execute procedure public.handle_visit_history();

-- Backfill
insert into public.visit_history (
    visit_id, entry_time, exit_time, employee_id, purpose_id, badge_id, 
    visitor_name, notes, signature, created_at, is_system_exit, exit_employee_id, 
    operation_type
)
select 
    id, entry_time, exit_time, employee_id, purpose_id, badge_id, 
    visitor_name, notes, signature, created_at, is_system_exit, exit_employee_id, 
    'BACKFILL'
from public.visits v
where not exists (select 1 from public.visit_history h where h.visit_id = v.id);

-- Enable RLS
alter table public.visit_history enable row level security;
create policy "Allow public read access" on public.visit_history for select using (true);
